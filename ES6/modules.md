# 用模块封装代码
在 **ES6** 之前，一个应用的每个 **JS** 文件所定义的所有内容都由全局作用域共享。当应用变得非常复杂时，这会造成许多问题，例如命名冲突、安全问题等。**ES6** 的设计目标之一就是要解决作用域问题，让 **JS** 应用更加有条理，更容易维护。

### 何为模块？
模块（**Modules**）是使用不同方法加载的 **JS** 文件（与 **JS** 原先的脚本加载方式相对）。这种不同模式很有必要，因为它与脚本（**script**） 有大大不同的语义：
1. 模块代码自动运行在严格模式下，并且没有任何办法跳出严格模式；
2. 在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在；
3. 模块顶级作用域的 `this` 值为 `undefined` ；
4. 模块不允许在代码中使用 **HTML** 风格的注释（这是 **JS** 来自于早期浏览器的历史遗留特性）；
5. 对于需要让模块外部代码访问的内容，模块必须导出它们；
6. 允许模块从其他模块导入绑定。

?> 模块最重要的功能是可以按需导出与导入代码的能力，而不用将所有内容放在同一个文件内。

### 基本的导出
想要把代码公开给其他模块，我们可以使用 `export` 关键字将代码导出给其他模块使用。最简单的方法就是把 `export` 放在函数、变量、类声明之前。

如下：
```js
    // 导出变量
    export var age = 23
    export let color = "red"
    export const name = "zzzhim"

    // 导出函数
    export function sum(num1, num2) {
        return num1 + num2
    }

    // 导出类
    export class React {
        constructor(length, width) {
            this.length = length
            this.width = width
        }
    }

    // 声明一个私有函数
    function add() {
        // ......
    }
```

上面被导出的函数或者类都有自己的名称，这是因为导出的函数声明与类声明必须要有名称。想要导出一个匿名函数或匿名类，需要使用 `default` 关键字（后面会提到）。

!> 在模块中未被导出的 变量、函数、类，在模块外部都不可被访问，这是因为它们在模块内是私有的。

### 基本的导入
我们可以在模块内使用 `import` 关键字来访问其他模块导出的功能。

`import` 语句有两个部分，一是需要导入的标识符，二是需要导入的标识符的来源模块。如下：
```js
    import { sum } from "./example.js"
```

`import` 的花括号指明了从给定模块导入对应的绑定， `from` 关键字则指明了需要导入的模块。

?> 当从模块导入了一个绑定时，该绑定表现的就像使用了 `const` 的定义。这意味着你不能再定义另一个同名变量（包括导入另一个同名绑定），也不能在对应的 `import` 语句之前使用此标识符（也就是要受到暂时性死区限制），更不能修改它的值。

###### 导入单个绑定
```js
    // 单个导入
    import { sum } from "./example.js"
```

###### 导入多个绑定
```js
    // 多个导入
    import { sum, React, age } from "./example.js"
```

###### 完全导入一个模块
```js
    // 完全导入
    import * as example from "./example.js"
```

在此例中，`example.js` 中所有导出的绑定都会被加载到一个名为 `example` 的对象中。这种导入格式被称为命名空间导入（**namespace import**），这是因为该 `example` 对象并不存在于 `example.js` 文件中，而是作为一个命名空间对象被创建使用。

?> 无论你对同一个模块使用了多少次 `import` 语句，该模块都只会被执行一次。在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他 `import` 所引用。

> 你只能在模块的顶级作用域使用 `export` 。类似的，你不能在一个语句内部使用 `import` ，也只能将其用在顶级作用域。
```js
    if (sum) {
        export sum // 语法错误
    }
```
```js
    function tryImport() {
        import { sum } from "./example.js" // 语法错误
    }
```